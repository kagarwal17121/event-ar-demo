<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"
  />
  <title>Event AR ‚Äî Multi</title>
  <style>
    :root { --bg:#0b0b0c; --panel:#121316; --text:#e9ecf1; --muted:#a7b0bb; --accent:#2f6bff; }
    html,body{height:100%;margin:0;background:#000;color:var(--text);font:15px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    #status{position:fixed;top:8px;left:8px;right:8px;z-index:50;padding:.45rem .7rem;background:#222a;border-radius:8px;font-size:12px;backdrop-filter: blur(4px);}
    #ui{position:fixed;top:48px;left:0;right:0;z-index:40;padding:.6rem;display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;background:linear-gradient(to bottom, #0009, #0000);}
    select,button{height:44px;border-radius:12px;border:1px solid #2a2d33;background:var(--panel);color:var(--text);}
    select{padding:0 .75rem;min-width:220px;}
    button{padding:0 16px;font-weight:600}
    .primary{background:var(--accent);border-color:var(--accent);color:#fff}
    .ghost{background:#1a1d22}
    #enter{position:fixed;bottom:24px;left:0;right:0;margin:0 auto;width:min(420px,86vw);height:56px;border-radius:18px}
    canvas{display:block}
    #overlayMsg{position:fixed;inset:0;display:none;align-items:center;justify-content:center;color:#ddd;background:#0000;pointer-events:none}
    #reticleHint{position:fixed;bottom:96px;left:0;right:0;text-align:center;color:#cbd5e1;font-size:13px;text-shadow:0 1px 2px #0007;}
  </style>
</head>
<body>
  <!-- top status strip -->
  <div id="status">boot‚Ä¶</div>

  <!-- controls -->
  <div id="ui">
    <label for="modelSel" style="opacity:.9">Model</label>
    <select id="modelSel"><option>Loading‚Ä¶</option></select>
    <button id="addBtn" class="primary">+ Add</button>
    <button id="undoBtn" class="ghost">‚ü≤ Undo</button>
    <button id="clearBtn" class="ghost">üóëÔ∏è Clear</button>
  </div>

  <div id="reticleHint" style="display:none;">Move your phone to find a surface ‚Ä¢ tap to place</div>

  <!-- big AR button -->
  <button id="enter" class="primary">üì∑ Enter AR</button>

  <!-- simple overlay to keep DOM overlay feature happy -->
  <div id="overlayMsg">AR running‚Ä¶</div>

  <script type="module">
    // --- Imports (ALL RELATIVE) ---
    import * as THREE from './lib/three/build/three.module.js';
    import { GLTFLoader } from './lib/three/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from './lib/three/examples/jsm/loaders/DRACOLoader.js';

    // ---------- UI helpers ----------
    const $ = sel => document.querySelector(sel);
    const statusEl = $('#status');
    const log = (msg) => { statusEl.textContent = msg; console.log('[AR]', msg); };

    const modelSel  = $('#modelSel');
    const addBtn    = $('#addBtn');
    const undoBtn   = $('#undoBtn');
    const clearBtn  = $('#clearBtn');
    const enterBtn  = $('#enter');
    const hintEl    = $('#reticleHint');

    // ---------- Load catalog ----------
    let CATALOG = [];
    async function loadCatalog() {
      try {
        log('Loading catalog‚Ä¶');
        const res = await fetch('./models/models.json', { cache:'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status + ' for models.json');
        const data = await res.json();
        // Accept either {models:[...]} or [...] shapes
        CATALOG = Array.isArray(data) ? data : (data.models || []);
        modelSel.innerHTML = '';
        CATALOG.forEach((m,i) => {
          const opt = document.createElement('option');
          opt.value = i;
          opt.textContent = m.name || m.id || m.file || ('Model '+(i+1));
          modelSel.appendChild(opt);
        });
        log('Catalog loaded');
      } catch (err) {
        console.error(err);
        modelSel.innerHTML = '<option>Failed to load catalog</option>';
        log('Catalog load error: ' + err.message);
      }
    }

    // ---------- Three.js scene ----------
    let renderer, scene, camera, xrRefSpace, xrHitSource = null;
    const placed = []; // stack for undo/clear
    let pendingToPlace = null; // {gltf, scale, yUp}
    let placingArmed = false;

    // reticle
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.12, 0.14, 32).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({ color: 0x1ea7ff, transparent:true, opacity:0.85 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;

    // loaders (GLTF + DRACO)
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('./lib/three/examples/jsm/libs/draco/'); // this folder must contain the 3 draco files
    gltfLoader.setDRACOLoader(draco);

    function initThree() {
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 40);
      scene.add(camera);

      const light = new THREE.HemisphereLight(0xffffff, 0x222233, 1.0);
      scene.add(light);

      scene.add(reticle);

      window.addEventListener('resize', () => {
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    }

    // ---------- Model loading ----------
    async function loadSelectedModel() {
      const idx = parseInt(modelSel.value, 10);
      const info = CATALOG[idx];
      if (!info) { log('Pick a model'); return; }

      // paths relative to THIS html
      const url = './models/' + (info.file || info.url || info.src);
      const scale = info.scale || 1;
      const yUp   = info.yUp !== false; // default true

      log('Loading model: ' + (info.name || info.file));
      return new Promise((resolve,reject)=>{
        gltfLoader.load(url, (gltf)=>{
          log('Model ready ‚Ä¢ tap to place');
          pendingToPlace = { gltf, scale, yUp };
          placingArmed = true;
          addBtn.classList.add('primary');
          hintEl.style.display = 'block';
          resolve(gltf);
        }, undefined, (err)=>{
          log('Model load error: ' + err.message);
          reject(err);
        });
      });
    }

    // ---------- AR session ----------
    async function beginAR() {
      if (!navigator.xr) { log('WebXR not available'); return; }

      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if (!supported) { log('immersive-ar not supported'); return; }

      const session = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['hit-test', 'dom-overlay'],
        domOverlay: { root: document.body }
      });

      renderer.xr.setReferenceSpaceType('local');
      await renderer.xr.setSession(session);

      const viewerSpace = await session.requestReferenceSpace('viewer');
      xrRefSpace = await session.requestReferenceSpace('local');
      xrHitSource = await session.requestHitTestSource({ space: viewerSpace });

      session.addEventListener('end', ()=>{
        xrHitSource = null; xrRefSpace = null;
        reticle.visible = false;
        hintEl.style.display = 'none';
        log('AR session ended');
      });

      // touch to place
      renderer.domElement.addEventListener('touchend', (e)=>{
        if (!placingArmed || !reticle.visible || !pendingToPlace) return;
        e.preventDefault();
        const { gltf, scale, yUp } = pendingToPlace;
        const obj = gltf.scene.clone(true);
        obj.traverse(o => { if (o.isMesh){ o.castShadow=false; o.receiveShadow=false; }});
        if (!yUp) obj.rotation.x = -Math.PI/2;
        obj.scale.setScalar(scale);
        obj.position.setFromMatrixPosition(reticle.matrix);
        obj.quaternion.setFromRotationMatrix(reticle.matrix);
        scene.add(obj);
        placed.push(obj);
        placingArmed = false;
        hintEl.style.display = 'none';
        addBtn.classList.remove('primary');
        log('Object placed ‚Ä¢ Add to place another');
      }, { passive:false });

      log('AR session started. Move phone; tap to place.');
      renderer.setAnimationLoop(onXRFrame);
    }

    function onXRFrame(time, frame) {
      const session = renderer.xr.getSession();
      if (!session || !xrHitSource || !xrRefSpace) { renderer.render(scene, camera); return; }

      const pose = frame.getViewerPose(xrRefSpace);
      reticle.visible = false;

      const results = frame.getHitTestResults(xrHitSource);
      if (results.length) {
        const hit = results[0];
        const hitPose = hit.getPose(xrRefSpace);
        reticle.visible = true;
        reticle.matrix.fromArray(hitPose.transform.matrix);
      }
      renderer.render(scene, camera);
    }

    // ---------- Wire UI ----------
    addBtn.onclick = () => loadSelectedModel();
    undoBtn.onclick = () => {
      const last = placed.pop();
      if (last) { scene.remove(last); last.traverse?.(o=>o.dispose?.()); log('Undo last'); }
    };
    clearBtn.onclick = () => {
      while (placed.length) scene.remove(placed.pop());
      log('Cleared');
    };
    enterBtn.onclick = () => beginAR();

    // ---------- Boot ----------
    initThree();
    loadCatalog();
  </script>
</body>
</html>
