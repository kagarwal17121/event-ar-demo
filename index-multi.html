<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Event AR â€” Multi</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; height:100%; background:#0b0b0b; color:#e8e8e8; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #log { position:fixed; top:0; left:0; right:0; z-index:5; background:#121212; color:#ddd; padding:6px 10px; font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  #hud { position:fixed; top:28px; left:0; right:0; z-index:4; background:#101010; border-bottom:1px solid #222; padding:10px; display:flex; gap:8px; align-items:center; }
  label { color:#a8a8a8; }
  select, button { height:40px; border-radius:10px; border:1px solid #2a2a2a; background:#1a1a1a; color:#fff; padding:0 12px; font:inherit; }
  button.primary { background:#2563eb; border-color:#2563eb; font-weight:700; }
  button.warn { background:#2b1a1a; border-color:#7a2b2b; }
  #stage { position:fixed; inset:0; z-index:1; display:block; }
  #enter { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; z-index:6; }
  #toast { position:fixed; left:50%; transform:translateX(-50%); bottom:90px; background:rgba(0,0,0,.7); padding:10px 14px; border-radius:12px; font-size:14px; display:none; z-index:7; }
</style>
</head>
<body>

<div id="log">bootâ€¦</div>

<div id="hud">
  <label for="model">Model</label>
  <select id="model"><option>Loadingâ€¦</option></select>
  <button id="add" class="primary">+ Add</button>
  <button id="undo">â†º Undo</button>
  <button id="clear" class="warn">ðŸ—‘ Clear</button>
</div>

<canvas id="stage"></canvas>
<button id="enter" class="primary">ðŸ“· Enter AR</button>
<div id="toast"></div>

<script type="module">
/* ===== Imports (local, no CDN) ===== */
import * as THREE from './lib/three/build/three.module.js?v=1';
import { GLTFLoader }  from './lib/three/examples/jsm/loaders/GLTFLoader.js?v=1';
import { DRACOLoader } from './lib/three/examples/jsm/loaders/DRACOLoader.js?v=1';

/* ===== UI helpers ===== */
const logEl = document.getElementById('log');
const toastEl = document.getElementById('toast');
const modelSel = document.getElementById('model');
const addBtn   = document.getElementById('add');
const undoBtn  = document.getElementById('undo');
const clearBtn = document.getElementById('clear');
const enterBtn = document.getElementById('enter');

function log(msg){ const t = new Date().toTimeString().slice(0,8); logEl.textContent = `${t} â€” ${msg}`; console.log('[AR]', msg); }
function toast(msg){ toastEl.textContent = msg; toastEl.style.display='block'; setTimeout(()=>toastEl.style.display='none', 2500); }

/* ===== Inline catalog (edit this list only) ===== */
const CATALOG = [
  { name: 'Podium',        url: './models/podium.glb' },
  { name: 'Concert Stage', url: './models/concert-stage.glb' },
  { name: 'Chair',         url: './models/chair.glb' },
  { name: 'Couch',         url: './models/couch.glb' },
  { name: 'Chaise',        url: './models/chaisehighpoly.glb' },
];

/* Populate dropdown */
modelSel.innerHTML = '';
for (const m of CATALOG) {
  const opt = document.createElement('option'); opt.value = m.url; opt.textContent = m.name; modelSel.appendChild(opt);
}
log(`catalog loaded (${CATALOG.length})`);

/* ===== Single global GLTFLoader + DRACO ===== */
const manager = new THREE.LoadingManager();
const gltfLoader = new GLTFLoader(manager);

const draco = new DRACOLoader(manager);
// Build an absolute URL to the Draco folder that contains:
// draco_wasm_wrapper.js, draco_decoder.js, draco_decoder.wasm
const dracoFolder = new URL('./lib/three/examples/jsm/libs/draco/', import.meta.url).href;
draco.setDecoderPath(dracoFolder);
draco.setDecoderConfig({ type:'wasm' });
draco.setWorkerLimit(1);
draco.preload();

gltfLoader.setDRACOLoader(draco);
log(`draco wired: ${!!gltfLoader.dracoLoader} @ ${dracoFolder}`);

/* ===== THREE scene (shared for preview + AR) ===== */
const canvas = document.getElementById('stage');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, 1.6, 3);

scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1.0));
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(0.5, 1, 0.5);
scene.add(dir);

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ===== Preview mode: load + drop at origin ===== */
function autoScaleTo1m(obj){
  obj.updateMatrixWorld(true);
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(); box.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z) || 1;
  const s = 1.2 / maxDim; // ~1.2m target
  obj.scale.multiplyScalar(s);
}

function loadAndAdd(url, placeAt){
  log('loading ' + url);
  gltfLoader.load(url, (gltf)=>{
    const root = gltf.scene || gltf.scenes[0];
    root.traverse(o=>{ if(o.isMesh){ o.castShadow = o.receiveShadow = true; o.frustumCulled = false; } });
    autoScaleTo1m(root);
    if (placeAt){ // AR: matrix provided
      root.matrix.copy(placeAt); root.matrix.decompose(root.position, root.quaternion, root.scale);
    } else { // Preview: origin
      root.position.set(0,0,0);
    }
    root.userData.isPlaced = true;
    scene.add(root);
    placements.push(root);
    log('loaded ' + url);
  }, undefined, (err)=>{
    console.error('GLB load failed:', url, err);
    toast(`Load failed: ${url.split('/').pop()}`);
    log(`model load error: ${err?.message || err}`);
  });
}

addBtn.addEventListener('click', ()=> loadAndAdd(modelSel.value, null));
undoBtn.addEventListener('click', ()=>{
  const last = placements.pop();
  if (last) { last.parent?.remove(last); log('Undo: removed last'); }
});
clearBtn.addEventListener('click', ()=>{
  while(placements.length){ const o = placements.pop(); o.parent?.remove(o); }
  log('Cleared all objects');
});

/* Keep preview running */
(function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();

/* ===== AR mode (hit-test + tap to place) ===== */
const placements = [];
let reticle = null;

async function startAR(){
  if (!navigator.xr){ toast('WebXR not available'); return; }
  const supported = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
  if (!supported){ toast('immersive-ar not supported'); return; }

  const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures:['hit-test','local-floor'] });
  renderer.xr.setReferenceSpaceType('local-floor'); await renderer.xr.setSession(session);

  const xrRefSpace = await session.requestReferenceSpace('local-floor');
  const viewerSpace = await session.requestReferenceSpace('viewer');
  const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

  // Reticle
  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color:0x4ea3ff })
  );
  reticle.matrixAutoUpdate = false; reticle.visible = false; scene.add(reticle);

  // Tap to place (XR select)
  session.addEventListener('select', ()=>{
    if (!reticle?.visible) return;
    loadAndAdd(modelSel.value, reticle.matrix.clone());
  });

  renderer.setAnimationLoop((t, frame)=>{
    if (!frame) return;
    const hits = hitTestSource ? frame.getHitTestResults(hitTestSource) : [];
    if (hits.length){
      const pose = hits[0].getPose(xrRefSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else {
      reticle.visible = false;
    }
    renderer.render(scene, camera);
  });

  session.addEventListener('end', ()=>{
    renderer.setAnimationLoop(null);
    reticle?.removeFromParent(); reticle=null;
    log('AR session ended');
  });

  log('AR started â€” move to find a surface; tap to place.');
}

enterBtn.addEventListener('click', startAR);

/* ===== Final readiness log ===== */
(async ()=>{
  const https = location.protocol === 'https:' || location.hostname === 'localhost';
  let hasXR = !!navigator.xr, immersive = false;
  if (hasXR) immersive = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
  log(`ready â€” secure:${https} hasXR:${hasXR} immersive-ar:${immersive}`);
})();
</script>
</body>
</html>
